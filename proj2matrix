import math
import time


class SquareMatrix:
    def __init__(self, size):
        self.N = size
        self.mat = []
        for _ in range(self.N):
            self.mat.append([])
        self.row = 0  # raczej niepotrzebne pole
        self.col = 0

    def matAddMat(self, mat2: 'SquareMatrix') -> 'SquareMatrix':  # '  ' -> forward reference, class doesn't exist yet
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat[row] += ([sum(val) for val in zip(self.mat[row], mat2.mat[row])])
            # self.mat[row] = ([sum(val) for val in zip(self.mat[row], mat2.mat[row])])
        return newMat

    def matMulVec(self, vec):
        newVec = []
        for row in range(self.N):
            num = 0
            for col in range(self.N):
                num += self.mat[row][col] * vec[row]
            newVec.append(num)
        return newVec

    def matMulScalar(self, scalar):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat[row] = [val * scalar for val in self.mat[row]]
        return newMat

    def matTrUpper(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row > col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def matTrLower(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row < col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def matDiagonal(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row != col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def forwardSub(self, b):
        x = [0] * self.N
        for row in range(self.N):
            aSum = 0
            for col in range(row):  # +1 ?
                aSum += self.mat[row][col] * x[col]
            x[row] = (b[row] - aSum) / self.mat[row][row]
        return x

    def norm(self, vec):
        suma = sum(x ** 2 for x in vec)
        return math.sqrt(suma)

    def normedRes(self, r, b):
        res = [x - y for x, y in zip(self.matMulVec(r), b)]
        return self.norm(res)

    def jacobi(self, b):
        r = [1] * self.N
        d = self.matDiagonal()
        l = self.matTrLower()
        u = self.matTrUpper()
        lu = l.matAddMat(u)
        minusD = d.matMulScalar(-1)
        db = d.forwardSub(b)

        res = self.normedRes(r, b)
        errorRes = res ** 30
        maxRes = 10 ** -9  # pow(10, -9)
        iterations = 0
        start = time.time()
        while res > maxRes:
            iterations += 1
            lur = lu.matMulVec(r)
            dlur = minusD.forwardSub(lur)
            #dlur = d.forwardSub(lur)
            #dlur = [x * -1 for x in dlur]
            r = dlur + db
            res = self.normedRes(r, b)
            if res >= errorRes:
                print("Norma bledu rezydualnego prawdopodobnie nie zbiega")
                end = time.time()
                print(str(iterations) + " iteracji, zajęło " + str(end - start) + " sekund")
                return [0]
        end = time.time()
        print(str(iterations) + "iteracji, zajęło " + str(end-start) + " sekund")
        return r

    def gaussSiedel(self):
        r = [1] * self.N
        d = self.matDiagonal()
        l = self.matTrLower()
        u = self.matTrUpper()

        dl = d.matAddMat(l)
        dlb = dl.forwardSub(b)
        minusDL = dl.matMulScalar(-1)

        res = self.normedRes(r, b)
        errorRes = res ** 30
        maxRes = 10 ** -9
        iterations = 0
        start = time.time()
        while res > maxRes:
            iterations += 1
            ur = u.matMulVec(r)
            dlur = minusDL.forwardSub(ur)

            r = dlur + dlb
            res = self.normedRes(r, b)
            if res >= errorRes:
                print("Norma bledu rezydualnego prawdopodobnie nie zbiega")
                end = time.time()
                print(str(iterations) + " iteracji, zajęło " + str(end - start) + " sekund")
                return [0]
        end = time.time()
        print(str(iterations) + "iteracji, zajęło " + str(end - start) + " sekund")
        return r

    def matPrint(self):
        for row in range(self.N):
            print(*self.mat[row])  # * -> print whole array in one line
            print()

    def matTestCreate(self):
        for row in range(self.N):
            for col in range(self.N):
                self.mat[row].append(3)

    def matBandCreate(self):
        a1 = 5 + 7
        a2 = -1
        a3 = -1
        start = 2
        current = start
        band = [a3, a2, a1, a2, a3]
        width = len(band)

        for row in range(self.N):
            zeroStart = math.ceil(width / 2) + row
            zeroEnd = -math.ceil(width / 2) + row
            for col in range(self.N):

                if col >= zeroStart or col <= zeroEnd:
                    num = 0
                else:
                    num = band[current]
                    current += 1
                # self.matAppend(num)
                self.mat[row].append(num)

            if start > 0:
                start -= 1
            current = start


# czasem macierz jest 2x wieksza (puste elementy)


N = 9 * 2 * 5
#
# s = SquareMatrix(N)
# s.matBandCreate()
# s.matPrint()
# d = SquareMatrix(N)
# d.matBandCreate()
# s = s.matAddMat(d)
# s.matPrint()
# test = SquareMatrix(N)
#
# test.matTestCreate()
# test = test.matTrUpper()
# test.matPrint()

# test.matTestCreate()test.matPrint()
# test.matPrint()

# test = test.matTrLower()
# test = test.matDiagonal()
# test.matPrint()

# test = test.matAddMat(test)
# test.matMulScalar(2)
# test.matPrint()
# tvec = []
# for i in range(N):
#     tvec.append(2)
# test.jacobi(tvec)
# v = test.forwardSub(tvec)
# print(v)
# v = test.matMulVec(tvec)
# print(v)

b = []
for i in range(N):
    b.append(math.sin(i * (8 + 1)))
m = SquareMatrix(N)
m.matBandCreate()
m.jacobi(b)
# print(b)
