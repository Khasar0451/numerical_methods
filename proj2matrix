import math
import time


def add2Vectors(a, b):
    return [x + y for x, y in zip(a, b)]


def sub2Vectors(a, b):
    return [x - y for x, y in zip(a, b)]


class SquareMatrix:
    def __init__(self, size):
        self.N = size
        self.mat = []
        for _ in range(self.N):
            self.mat.append([])
        self.row = 0  # raczej niepotrzebne pole
        self.col = 0

    def matAddMat(self, mat2: 'SquareMatrix') -> 'SquareMatrix':  # '  ' -> forward reference, class doesn't exist yet
        newMat = SquareMatrix(self.N)
        for i in range(self.N):
            row = []
            for j in range(self.N):
                row.append(self.mat[i][j] + mat2.mat[i][j])
            newMat.mat[i] = row
            # newMat.mat[row] += ([sum(val) for val in zip(self.mat[row], mat2.mat[row])])
            # self.mat[row] = ([sum(val) for val in zip(self.mat[row], mat2.mat[row])])
        return newMat

    def matMulVec(self, vec):
        newVec = []
        for row in range(self.N):
            num = 0
            for col in range(self.N):
                num += self.mat[row][col] * vec[col]
            newVec.append(num)
        return newVec

    def matMulScalar(self, scalar):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat[row] = [val * scalar for val in self.mat[row]]
        return newMat

    def matTrUpper(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row >= col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def matTrLower(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row <= col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def matDiagonal(self):
        newMat = SquareMatrix(self.N)
        for row in range(self.N):
            newMat.mat.append([])
            for col in range(self.N):
                if row != col:
                    newMat.mat[row].append(0)
                else:
                    newMat.mat[row].append(self.mat[row][col])
        return newMat

    def forwardSub(self, b):
        x = [0] * self.N
        for row in range(self.N):
            aSum = 0
            for col in range(row):  # +1 ?
                aSum += self.mat[row][col] * x[col]
            x[row] = (b[row] - aSum) / self.mat[row][row]
        return x

    def norm(self, vec):
        suma = sum(x ** 2 for x in vec)
        return math.sqrt(suma)

    def normedRes(self, r, b):
        res = []

        print("m: ")
        for row in self.mat:
            print(*row, sep="\t")
        print()

        mr = self.matMulVec(r)
        print("mr: ")
        for row in mr:
            print(row, sep="\t")
        print()
        res = sub2Vectors(mr, b)
        # for i in range(self.N):
        #     res.append(x - b[row])
        # res = [x - y for x, y in zip(self.matMulVec(r), b)]
        print("unnormed res: ")
        for row in res:
            print(row, sep="\t")
        print()

        return self.norm(res)

    def direct(self, b):
        return self.forwardSub(b)

    def residualErrorTooBig(self, iterations, start, res):
        print("not acceptable error - terminated, with res = " + str(res))
        end = time.time()
        print(str(iterations) + " iteracji, zajęło " + str(end - start) + " sekund")

    def residualErrorRising(self, iterations, start):
        print("Norma bledu rezydualnego prawdopodobnie nie zbiegnie")
        end = time.time()
        print(str(iterations) + " iteracji, zajęło " + str(end - start) + " sekund")

    def jacobi(self, b):
        r = [1] * self.N
        print("r: ")
        for row in r:
            print(row, sep="\t")
        print()

        d = self.matDiagonal()
        l = self.matTrLower()
        u = self.matTrUpper()
        lu = l.matAddMat(u)
        print("lu: ")
        for row in lu.mat:
            print(*row, sep="\t")
        print()
        # print('\n'.join(' '.join(str(x) for x in row) for row in lu.mat))
        # print(lu.mat)
        minusD = d.matMulScalar(-1)

        db = d.forwardSub(b)
        print("db: ")
        for row in db:
            print(row, sep="\t")
        print()

        #

        res = self.normedRes(r, b)
        print("res: " + str(res))
        print()

        errorRes = res ** 30
        maxRes = pow(10, -9)
        iterations = 0
        start = time.time()
        terminationCountdown = 0
        resLast = res
        resarr = []
        # dlu = minusD.forwardSub(lu.mat)
        while res > maxRes:
            #   print("res: " + str(res) + "  ||  maxRes: " + str(maxRes))
            iterations += 1

            ###w drugiej itracji lur jest inny niz w matlab

            lur = lu.matMulVec(r)
            print("lur : ")
            for row in lur:
                print(row, sep="\t")
            print()

            dlur = minusD.forwardSub(lur)
            print("dlur : ")
            for row in dlur:
                print(row, sep="\t")
            print()

            # dlur = minusD.forwardSub(lu.mat)
            # dlur = dlu.matMulVec(r)

            r = add2Vectors(dlur, db)
            print("r: ")
            for row in r:
                print(row, sep="\t")
            print()

            print("b: ")
            for row in b:
                print(row, sep="\t")

            res = self.normedRes(r, b)
            print("res: " + str(res))
            print()

            resarr.append(res)
            if res >= errorRes:
                self.residualErrorRising(iterations, start)
                return [0]

            if resLast == res:
                terminationCountdown += 1
                if terminationCountdown == 200:
                    self.residualErrorTooBig(iterations, start, res)
                    return [0]
            else:
                terminationCountdown = 0
            resLast = res
            print("____________________________")

        end = time.time()
        print(str(iterations) + "iteracji, zajęło " + str(end - start) + " sekund")
        return r

    def gaussSiedel(self, b):
        r = [1] * self.N
        d = self.matDiagonal()
        l = self.matTrLower()
        u = self.matTrUpper()

        dl = d.matAddMat(l)
        dlb = dl.forwardSub(b)
        minusDL = dl.matMulScalar(-1)

        res = self.normedRes(r, b)
        resLast = res
        errorRes = res ** 30
        maxRes = 10 ** -9
        iterations = 0
        terminationCountdown = 0
        start = time.time()
        while res > maxRes:
            iterations += 1
            ur = u.matMulVec(r)
            dlur = minusDL.forwardSub(ur)

            r = add2Vectors(dlur, dlb)
            res = self.normedRes(r, b)
            if resLast == res:
                terminationCountdown += 1
                if terminationCountdown == 200:
                    self.residualErrorTooBig(iterations, start, res)
                    return [0]
            else:
                terminationCountdown = 0
            resLast = res
            if res >= errorRes:
                self.residualErrorRising(iterations, start)
                return [0]

        end = time.time()
        print(str(iterations) + "iteracji, zajęło " + str(end - start) + " sekund")
        return r

    def LUFactorization(self, b):
        l = self.matTrLower()
        u = self.matTrUpper()

        for i in range(self.N):
            for k in range(i, self.N):
                sum = 0

    def matPrint(self):
        for row in range(self.N):
            print(*self.mat[row])  # * -> print whole array in one line
            print()

    def matTestCreate(self):
        for row in range(self.N):
            for col in range(self.N):
                self.mat[row].append(3)

    def matBandCreate(self, a1, a2, a3):
        start = 2
        current = start
        band = [a3, a2, a1, a2, a3]
        width = len(band)

        for row in range(self.N):
            zeroStart = math.ceil(width / 2) + row
            zeroEnd = -math.ceil(width / 2) + row
            for col in range(self.N):

                if col >= zeroStart or col <= zeroEnd:
                    num = 0
                else:
                    num = band[current]
                    current += 1
                # self.matAppend(num)
                self.mat[row].append(num)

            if start > 0:
                start -= 1
            current = start


# czasem macierz jest 2x wieksza (puste elementy)


N = 5  # 9 * 2 * 5

b = []
for i in range(N):
    b.append((i + 2))
#     b.append(math.sin(i * (8 + 1)))
print(b)
m = SquareMatrix(N)
# m.matBandCreate(3, -1, -1)

m.matBandCreate(12, -1, -1)

# r1 = m.direct(b)
# print("Wynik bezpośredni: " + str(r1) + "\n")

r2 = m.jacobi(b)
print("Wynik Jacobi: " + str(r2) + "\n")

r3 = m.gaussSiedel(b)
print("Wynik Gauss-Seidel: " + str(r3) + "\n")

m.matBandCreate(3, -1, -1)
# print(b)
